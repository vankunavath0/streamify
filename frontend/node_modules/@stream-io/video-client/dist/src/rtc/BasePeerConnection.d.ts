import type { CallEventListener, Logger } from '../coordinator/connection/types';
import { CallState } from '../store';
import { PeerType, TrackType, WebsocketReconnectStrategy } from '../gen/video/sfu/models/models';
import { StreamSfuClient } from '../StreamSfuClient';
import { AllSfuEvents, Dispatcher } from './Dispatcher';
import { StatsTracer, Tracer } from '../stats';
export type OnReconnectionNeeded = (kind: WebsocketReconnectStrategy, reason: string) => void;
export type BasePeerConnectionOpts = {
    sfuClient: StreamSfuClient;
    state: CallState;
    connectionConfig?: RTCConfiguration;
    dispatcher: Dispatcher;
    onReconnectionNeeded?: OnReconnectionNeeded;
    tag: string;
    enableTracing: boolean;
    iceRestartDelay?: number;
};
/**
 * A base class for the `Publisher` and `Subscriber` classes.
 * @internal
 */
export declare abstract class BasePeerConnection {
    protected readonly logger: Logger;
    protected readonly peerType: PeerType;
    protected readonly pc: RTCPeerConnection;
    protected readonly state: CallState;
    protected readonly dispatcher: Dispatcher;
    protected sfuClient: StreamSfuClient;
    private onReconnectionNeeded?;
    private readonly iceRestartDelay;
    private iceRestartTimeout?;
    protected isIceRestarting: boolean;
    private isDisposed;
    protected trackIdToTrackType: Map<string, TrackType>;
    readonly tracer?: Tracer;
    readonly stats: StatsTracer;
    private readonly subscriptions;
    private unsubscribeIceTrickle?;
    protected readonly lock: string;
    /**
     * Constructs a new `BasePeerConnection` instance.
     */
    protected constructor(peerType: PeerType, { sfuClient, connectionConfig, state, dispatcher, onReconnectionNeeded, tag, enableTracing, iceRestartDelay, }: BasePeerConnectionOpts);
    private createPeerConnection;
    /**
     * Disposes the `RTCPeerConnection` instance.
     */
    dispose(): void;
    /**
     * Detaches the event handlers from the `RTCPeerConnection`.
     */
    detachEventHandlers(): void;
    /**
     * Performs an ICE restart on the `RTCPeerConnection`.
     */
    protected abstract restartIce(): Promise<void>;
    /**
     * Attempts to restart ICE on the `RTCPeerConnection`.
     * This method intentionally doesn't await the `restartIce()` method,
     * allowing it to run in the background and handle any errors that may occur.
     */
    protected tryRestartIce: () => void;
    /**
     * Handles events synchronously.
     * Consecutive events are queued and executed one after the other.
     */
    protected on: <E extends keyof AllSfuEvents>(event: E, fn: CallEventListener<E>) => void;
    /**
     * Appends the trickled ICE candidates to the `RTCPeerConnection`.
     */
    protected addTrickledIceCandidates: () => void;
    /**
     * Sets the SFU client to use.
     *
     * @param sfuClient the SFU client to use.
     */
    setSfuClient: (sfuClient: StreamSfuClient) => void;
    /**
     * Returns the result of the `RTCPeerConnection.getStats()` method
     * @param selector an optional `MediaStreamTrack` to get the stats for.
     */
    getStats: (selector?: MediaStreamTrack | null) => Promise<RTCStatsReport>;
    /**
     * Maps the given track ID to the corresponding track type.
     */
    getTrackType: (trackId: string) => TrackType | undefined;
    /**
     * Checks if the `RTCPeerConnection` is healthy.
     * It checks the ICE connection state and the peer connection state.
     * If either state is `failed`, `disconnected`, or `closed`,
     * it returns `false`, otherwise it returns `true`.
     */
    isHealthy: () => boolean;
    /**
     * Handles the ICECandidate event and
     * Initiates an ICE Trickle process with the SFU.
     */
    private onIceCandidate;
    /**
     * Converts the ICE candidate to a JSON string.
     */
    private asJSON;
    /**
     * Handles the ConnectionStateChange event.
     */
    private onConnectionStateChange;
    /**
     * Handles the ICE connection state change event.
     */
    private onIceConnectionStateChange;
    private handleConnectionStateUpdate;
    /**
     * Handles the ICE candidate error event.
     */
    private onIceCandidateError;
    /**
     * Handles the ICE gathering state change event.
     */
    private onIceGatherChange;
    /**
     * Handles the signaling state change event.
     */
    private onSignalingChange;
}
